\documentclass[11pt,a4paper]{report}
 
\usepackage[portuguese]{babel}
\usepackage{indentfirst}
%Em windows
 
\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage[tt]{titlepic}
\usepackage[small,bf]{caption}

\usepackage{listings}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\definecolor{light-gray}{gray}{0.95}
\lstset{language=Java,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\usepackage{fullpage}
\usepackage{float}

\begin{document}

\begin{titlepage}

\begin{center}

\begin{figure}[htp]
  \centering
  \includegraphics{feup}
 
\end{figure}

\vspace{10 mm}

\textsc{\large Mestrado Integrado em Engenharia Informática e Computação} \\
\textsc{\large Agentes e Inteligência Artificial Distribuída} \\
\textsc{\normalsize 4º Ano} \\ 
\vspace{10 mm}
\textsc{\LARGE Determinação de percursos usando agentes BDI} \\
\textsc{\normalsize Relatório Final} \\

% Title
\vspace{30 mm}
% Author and supervisor
\emph{Autores:}\\
Bruno Filipe Neves Ferreira - 080509088 - ei08088@fe.up.pt \\
Carlos Tiago da Rocha Babo - 080509118 - ei08118@fe.up.pt \\
Hélder Alexandre dos Santos Moreira - 080509170 - ei08170@fe.up.pt

\vfill

% Bottom of the page
{\large \today}

\end{center}

\end{titlepage}

\newpage

\tableofcontents
\setcounter{tocdepth}{1}


\chapter{Objetivo}

\section{Descrição do cenário}

Numa viagem de automóvel o condutor tem que tomar várias decisões até chegar ao seu destino. Tendo em mente que o agente condutor pode ter várias intenções sobre o percurso a realizar, a escolha do caminho tem como base essas intenções. \\

Independentemente da intenção do condutor (chegar rapidamente a um local ou realizar um percurso turístico), o agente não conhece antecipadamente as condições do percurso escolhido. Apenas toma conhecimento dessas condições quando estas se encontram no seu campo de visão, ou então quando o rádio informa da ocorrência de um acidente. \\


\section{Objetivos do trabalho}

No âmbito da Unidade Curricular de Agentes e Inteligência Artificial Distribuída, o objetivo deste trabalho é criar um sistema multi-agente que consiga recolher informações sobre o espaço e indicar ao condutor qual o percurso que este deve tomar, tendo em conta os vários estímulos possíveis: acidentes, pontos de interesse, estado do tempo, rádio, entre outros.
O sistema deve avaliar os estímulos (condições do percurso), bem como as condições pré-definidas de modo a que o condutor chegue ao destino do modo pretendido. \\

\chapter{Especificação}

\section{Identificação e caraterização dos agentes}

A aplicação contempla dois agentes, Driver e Rádio, e uma \emph{capability}, \textit{GPS}. \\

\subsection{\textit{GPS}}

A capacidade \textit{GPS} tem como objetivo indicar ao condutor qual o percurso que este deve tomar de acordo com o seu desejo de viagem (direta ou turística) e com as condições do meio externo. Estas condições do meio externo são parte integrante desta capacidade (\emph{beliefs}), tendo ela assim informação sobre os vários componentes do espaço como pontos de interesse, ponto inicial e final da viagem, o mapa das estradas, entre outros. \\

Em caso de viagem turística, para encontrar o caminho a seguir, começa por verificar quais os pontos de interesse que correspondem às condições presentes no momento, isto é, quais os pontos de interesse ainda não visitados que cumprem com o estado do tempo atual e que cumprem também as precedências impostas.
São assim eliminados a priori os pontos de interesse não válidos por um qualquer motivo.
De seguida é analisado o caminho mais curto a seguir até cada um destes pontos e escolhido o mais curto como o próximo caminho a seguir, garantindo assim a escolha do "melhor" ponto de interesse. \\

Após todos os pontos de interesse estarem visitados ou não existirem condições para visitar os que ainda não estão, o \textit{GPS} encaminha o Driver para o ponto final da viagem, situação que também se verifica aquando da viagem direta em que são ignorados os pontos de interesse e o Driver é encaminhado diretamente para o ponto final. \\

A escolha de caminho feita pelo \textit{GPS} pode ser interrompida de duas formas: o agente Driver avista um acidente no seu raio de visão ou o agente Rádio comunica através de mensagem a existência de um acidente no mapa de estradas. Em ambos os casos a estratégia seguida pelo \textit{GPS} é idêntica: marca no seu mapa de estradas o acidente (ficando assim o acidente referenciado e sendo considerado em futuros cálculos) e verifica a necessidade de recalcular a rota do Driver. O procedimento para recalcular a rota é idêntico ao já explicado, visto que o acidente foi marcado no mapa pelo \textit{GPS} e portanto todos os caminhos que passem pelo menos não serão considerados. \\

\subsection{\textit{Driver}}

O agente Driver importa a capacidade \textit{GPS} para fazer uso do seu conhecimento tal como acontece numa situação real de utilização de um sistema de \textit{GPS}.
Num determinado momento o Driver tem conhecimento do ponto inicial da viagem, do ponto final e do ponto de interesse para onde se está a deslocar para além de saber se está a realizar uma viagem do tipo turística ou direta. \\

O objetivo principal do agente passa por analisar o ambiente circundante (raio de visão) verificando a existência de acidentes. Caso seja avistado um acidente este é marcado no mapa e o \textit{GPS} que irá recalcular a nova rota a seguir.
 
\subsection{\textit{Rádio}} 
 
O agente Radio funciona como um rádio real, avisando o condutor de todos os acidentes que existem no mapa. O agente tem como conhecimento o próprio mapa, estando assim ciente de todos os acidentes, quer sejam os iniciais, quer os que são adicionados em runtime. \\

O Radio comunica através de eventos por mensagem com o Driver, indicando numa primeira comunicação todos os acidentes e posteriormente aquando do aparecimento de novos acidentes, enviando uma nova comunicação em que são apenas enviados os novos acidentes.

\subsection{\textit{Aplicação}} 

A aplicação recorre às funcionalidades disponibilizadas pelo \emph{Jadex} 2.0 e tem como elemento principal um espaço 2D da classe \emph{Grid2D} que aloja vários elementos:

\begin{itemize}

\item {\bf Mapa de estradas} \\
Representa os caminhos onde o condutor pode movimentar-se e é representado através de células que irão indicar se é um caminho válido ou não . Esta representação tem como objetivo permitir o mapeamento do mapa numa matriz, facilitando a determinação de percursos.

\item {\bf Pontos de interesse} \\
São os pontos de interesse que o condutor deve visitar caso faça uma visita turística. Podem conter propriedades específicas, tais como o facto de só permitir visitas num determinado estado atmosférico ou também uma pré-condição para a visita (a visita de outro ponto de interesse por exemplo).

\item {\bf Acidentes}  \\
Representam um obstáculo incontornável na estrada e que obrigará o condutor a procurar outro caminho. Tal como os pontos de interesse, podem conter propriedades específicas de acordo com o estado atmosférico (só se encontra ativo em tempo de chuva por exemplo).

\item {\bf Ponto inicial da viagem}  \\
Representa o ponto inicial da viagem a partir do qual o condutor partirá.

\item {\bf Ponto final da viagem}  \\
Representa o ponto final da viagem para o qual o condutor tem como objetivo dirigir-se.

\end{itemize}

\section{Protocolos de interação}


\begin{figure}[htp]
  \centering
  \includegraphics[width=0.8\textwidth]{interacao}
  \caption{Esquema representativo das interações entre os vários componentes.}
\end{figure}


\chapter{Desenvolvimento}

\section{Ferramentas utilizadas}

O \emph{Jadex} BDI 2.0 é um motor que permite especificar agentes inteligentes baseado no modelo \emph{Belief-Desire-Intention} com recurso a \emph{XML} e Java. Uma das principais vantagens da ferramenta é não introduzir nenhuma linguagem de programação nova, permitindo usar \emph{IDEs} focados no desenvolvimento orientado a objetos, como o \textit{NetBeans}. \\

Para a interface gráfica recorreu-se ao conhecido \textit{Swing}, que permite desenvolver interfaces gráficas em \textit{Java} de forma simples e versátil. \\

Com o objetivo de ter um controlo de versões do projeto recorreu-se ao \textit{Git}, que permite de forma simples e eficaz manter um repositório sempre atualizado, assim como resolver conflitos de código facilmente.

\subsection{Características Principais do Jadex}

Os agentes racionais têm uma representação explícita no ambiente e dos objetivos que estão a tentar atingir. Estes são racionais, pois escolhem sempre a ação mais promissora (de acordo com a base de conhecimento do mundo) para atingir os seus objetivos. Dado que normalmente não têm conhecimento dos efeitos de cada ação previamente, os agentes deliberam sempre sobre as opções disponíveis.\\

Em 1987, Bratman introduziu uma arquitetura para descrever os agentes racionais. Esta  consiste em explorar as atitudes mentais que geram as ações do homem - crenças, desejos e intenções. Assim, as crenças captam as atitudes de informação, os desejos as atitudes de motivação, e as intenções as atitudes de deliberação dos agentes. Mais tarde, Rao e Geoff adotaram este modelo e transformaram-no numa teoria mais formal e num modelo de execução para software de agentes, baseado na noção de crenças, objetivos e planos (\emph{beliefs}, \emph{goals} e \emph{plans}).\\

Deste modo, o \emph{Jadex} reaproveitou o modelo de Rao e Geoff e portou-o para o contexto da programação orientada a objetos. Assim, os \emph{beliefs}, \emph{goals} e \emph{plans} representam objetos de classes que são criadas e manipuladas no contexto de cada agente. Os agentes comportam  \emph{beliefs}, representados por qualquer tipo de objeto Java e que pertencem à sua \emph{beliefbase}. Os \emph{goals} representam motivações concretas (estados a atingir) e que influenciam o comportamento do agente. Para atingir os seus objetivos (\emph{goals}), o agente executa planos (\emph{plans}), que são descritos em Java.\\

Os agentes podem ainda comunicar entre si com recurso a eventos internos (\textit{internalevent}) ou eventos externos (\textit{messageevent}). Os eventos internos permitem que o agente comunique dentro de si. Isto é, se um plano enviar uma notificação interna, todos os outros planos que registaram interesse nesse evento serão notificados. Os eventos externos, também conhecidos por mensagens, permitem enviar e receber mensagens entre agentes. \\ 

Este modelo comporta, desta forma, duas componentes essenciais. Por um lado, o agente reage a mensagens, eventos internos e \emph{goals} selecionando e executando \emph{plans}. Por outro lado, o agente delibera continuamente sobre os seus \emph{goals} atuais, adaptando-se às condições de cada momento.\\


\subsection{Ambiente de desenvolvimento}

O ambiente de desenvolvimento escolhido foi o \textit{NetBeans}, pois é um \textit{IDE} (\textit{Integrated development environment}) com uma excelente integração com o \textit{Swing} e que reconhece a sintaxe \textit{XML} para a declaração de agentes.  \\

Para desenvolver o projeto em \textit{Jadex}, foi descarregada a versão mais recente do \textit{site} oficial (2.0), que inclui as bibliotecas em formato \textit{*.jar} necessárias. \\

Em relação à utilização do \textit{Git}, recorreu-se à consola do sistema operativo. \\

\section{Estrutura da aplicação}
\subsection{Módulos da aplicação}
A aplicação é composta por dois grandes módulos. A Interface representa as classes \textit{Java} que implementam a interface externa ao próprio \textit{Jadex}. Nela estão incluídas a janela com o \textit{log} do utilizador e os seus \textit{beliefs}, a janela que permite adicionar novos componentes ao mapa da estrada e a janela que permite começar a simulação e consultar informação relativa ao cenário atual. \\ 

Por outro lado, o módulo da Aplicação contém os agentes, a \textit{capability} \textit{GPS} e o Mundo - que inclui os pontos de interesse, os acidentes e o mapa de estrada. O Condutor importa a capacidade \textit{GPS}, que lhe permite movimentar pelo espaço. Por sua vez, é o \textit{GPS} que tem acesso ao mundo em si, e que lhe permite calcular a rota do condutor. De acordo com a especificação, o \textit{GPS} não tem acesso aos acidentes \textit{à priori}. Por último, o agente Rádio tem acesso direto aos acidentes ao aceder ao Mundo e comunica-os ao condutor, caso essa opção esteja ativa.\\ 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{components}
  \caption{Esquema representativo dos módulos da aplicação.}
\end{figure}

\subsection{Detalhes revelantes da implementação}

\textbf{Objetos mais utilizados (e referenciados no relatório)}

\begin{itemize}
\item{\textit{ISpaceObject} - representação de um objeto do espaço. Permite aceder a várias informações, nomeadamente ao seu \textit{ID}, à sua posição e às suas propriedades.}
\item{\textit{Grid2D} - representação do espaço em si. Permite aceder a todos os objetos do espaço, assim como apaga-los ou inserir novos.}
\item{\textit{IVector2} - representação de um vetor (com coordenadas \textit{x} e \textit{y}) do espaço 2D.}
\item{\textit{IBDIExternalAccess} - interface que permite aceder a um agente em \textit{threads} externas (fora do seu âmbito).}
\item{\textit{IBDIInternalAccess} - interface que permite aceder às propriedades internas de um agente.}
\end{itemize}


Tendo em conta os objetivos do projeto, podemos identificar quatro estruturas principais: o condutos, o \textit{GPS}, o rádio e o Mundo em si. \\

\textbf{Condutor}

\begin{itemize}
\item{\textit{Beliefs}}

\begin{itemize}
\item{\textit{(ISpaceObject) Myself (referência)} - objeto que o representa no espaço.}
\item{\textit{(ISpaceObject) POI} (ponto de interesse) (referência) - ponto de interesse a visitar atualmente.}
\item{\textit{(ISpaceObject)} Acidente (referência) - acidente a tentar evitar no momento (quando não há nenhum, o belief não contém qualquer informação).}
\item{\textit{(Boolean)} Turística - booleano que permite saber se está em modo turístico ou modo direto.}
\item{\textit{(Boolean)Newradiomsg} - booleano que indica se há alguma mensagem de rádio nova para analisar.}
\end{itemize}

\item{\textit{Goals}}

\begin{itemize}
\item{\textit{AnalyzeAccident} - acionado quando há um novo acidente no campo de visão e é necessário verificar se interfere com o \textit{goal} atual.}
\item{\textit{AnalyzeRadioMsg} - acionado quando há uma nova mensagem de rádio e é necessário verificar se interfere com o \textit{goal} atual.}
\item{\textit{GoDestiny} - acionado no início da execução do agente, pois é este o \textit{goal} principal do agente, chegar ao seu destino final.}
\end{itemize}

\item{\textit{Plans}}

\begin{itemize}
\item{\textit{GoDestiny} - acionado quando há a intenção do agente em ir para uma dada posição.}
\item{\textit{AvoidAccident} - acionado quando há a intenção do agente em evitar um certo acidente, recalculando a rota atual.}
\item{\textit{AccidentInform} - acionado quando há uma mensagem nova do rádio por ler.}
\end{itemize}

\item{\textit{Events}}

\begin{itemize}
\item{\textit{AccidentInform} - registo para a receção de mensagens de rádio com novos acidentes.}
\end{itemize}


\end{itemize}

\textbf{\textit{GPS}}

\begin{itemize}
\item{Beliefs}

\begin{itemize}
\item{\textit{(ISpaceObject) Myself} - objeto que o representa no espaço.}
\item{\textit{(ISpaceObject) POI} - ponto de interesse a visitar atualmente.}
\item{\textit{(ISpaceObject)} Acidente - acidente a tentar evitar no momento (quando não há nenhum, o \textit{belief} não contém qualquer informação.}
\item{\textit{(Grid2D) Environment} - ambiente em que se insere com a informação dos pontos de interesse e estradas.}
\end{itemize}

\item{Goals}

\begin{itemize}
\item{\textit{MoveDest} - intenção de se deslocar até um dado ponto.}
\end{itemize}

\item{Plans}

\begin{itemize}
\item{\textit{GoDestination} - acionado quando há intenção de calcular a rota para um dado ponto.}
\end{itemize}

\end{itemize}

\textbf{Rádio}

\begin{itemize}
\item{Beliefs}

\begin{itemize}
\item{\textit{(Grid2D) Environment} - ambiente em que se insere com a informação dos acidentes.}
\end{itemize}

\item{Plans}

\begin{itemize}
\item{\textit{InformAccident} - acionado quando é necessário mandar informação relativa a novos acidentes.}
\end{itemize}

\item{\textit{Events}}

\begin{itemize}
\item{\textit{InformAccident} - registo para o envio de mensagens de rádio com a informação de novos acidentes.}
\end{itemize}

\end{itemize}

\textbf{Mundo}

\begin{itemize}
\item{Objetos}

\begin{itemize}
\item{\textit{Driver} - objeto que representa um agente do tipo \textit{Driver}.}
\item{\textit{POI} - objeto que representa os pontos de interesse.}
\item{\textit{Cell} - objeto que no seu conjunto representa as estradas.}
\end{itemize}

\item{Agentes}

\begin{itemize}
\item{\textit{Driver} - agente do tipo condutor.}
\item{\textit{Radio} - agente do tipo rádio.}
\end{itemize}

\end{itemize}

\textbf{Implementação do deslocamento do condutor \\}

Para deslocar o condutor no espaço foi necessário implementar um algoritmo para encontrar o melhor caminho entre dois pontos. Assim, escolheu-se o algoritmo A*, abordado na unidade curricular de Inteligência Artificial. Dada uma matriz e dois pontos, é calculado o caminho mais curto entre eles. Na matriz, as células com caminho são representadas pelo valor um, e as restantes pelo valor zero. \\

Desta forma, a primeira operação a fazer quando surge a intenção de um agente em ir de uma posição para a outra, é calcular o caminho entre essas duas posições. Se existir caminho, é criada uma \textit{task} (\textit{MoveTask}) que desloca o condutor até à posição pretendida. Esta \textit{task} é executada a cada \textit{tick} de relógio da aplicação, movimentando o condutor de acordo com a velocidade definida previamente para os objetos do ambiente. \\

\begin{lstlisting}
...
//posição do destino final
final IVector2 destination = (IVector2) getProperty(PROPERTY_DESTINATION); 

//posição da célula intermédia adjacente
final IVector2 interdestination = new Vector2Double(path.get(0).x, path.get(0).y);
 
//valor definido para a velocidade
double speed = ((Number) obj.getProperty(PROPERTY_SPEED)).doubleValue();
 
//distância máxima que pode percorrer, tendo em conta o progresso do deslocamento atual
double maxdist = progress * speed * 0.001; 

//posição atual do condutor
IVector2 loc = (IVector2) obj.getProperty(Space2D.PROPERTY_POSITION);

//nova posição baseada na posição atual, posição final e distância máxima que pode percorrer
IVector2 newloc = ((Space2D) space).getDistance(loc, interdestination).getAsDouble() <= maxdist? interdestination : interdestination.copy().subtract(loc).normalize().multiply(maxdist).add(loc); 

//movimento para a nova localização
((Space2D) space).setPosition(obj.getId(), newloc); 

//se a nova localização for a da posição intermédia desejada, essa célula é removida do caminho, pois estamos nela
if (newloc == interdestination) {path.remove(0);}
\end{lstlisting} 
\vspace{5 mm}

Durante a execução desta \textit{task} é verificado a cada momento se existe algum acidente na área de visão do condutor (também definida para os objetos do ambiente). Ao encontrar um novo acidente ainda não avistado, o conhecimento do condutor é atualizado convenientemente. Tendo em conta que esta movimentação dá-se no espaço em si, o \textit{Jadex} dispões de um acesso externo (\textit{IBDIExternalAccess}) que permite aceder aos \textit{beliefs} do condutor, para serem atualizados com a nova informação.  \\


\begin{lstlisting}
...
//acedendo ao scope da task é possível criar um acesso externo ao agente, pois foi este que iniciou a task
final IBDIExternalAccess agent = (IBDIExternalAccess) getProperty(PROPERTY_SCOPE); 

//raio de visão do condutor
double vision = ((Number) obj.getProperty(PROPERTY_VISION)).doubleValue(); 

//objetos que estão no raio de visão do condutor
final Set objects = ((Space2D) space).getNearObjects((IVector2) obj.getProperty(Space2D.PROPERTY_POSITION), new Vector1Double(vision)); 

//como a execução do agente não está sincronizada com a aplicação em si, é necessário registar um step que é efetuado no próximo tick do agente
agent.scheduleStep((IComponentStep) new IComponentStep<Void>() {
 public IFuture<Void> execute(IInternalAccess ia) {
  //acesso interno do agente
  IBDIInternalAccess bia = (IBDIInternalAccess) ia;
   
  ...
  //acede-se ao belief acidente e atualiza-se com o novo acidente encontrado
  bia.getBeliefbase().getBelief("acidente").setFact(so); 
  ...
  
  return IFuture.DONE; 
 }
});
\end{lstlisting}
\vspace{5 mm}

\textbf{Troca de mensagens entre o rádio e o condutor \\}

A troca de mensagens entre o rádio e o condutor é unidirecional. Isto é, o condutor recebe mensagens do rádio, e não o contrário. Para enviar mensagens, é necessário registar o evento na declaração \textit{XML} do rádio, especificando o protocolo de comunicação, o tipo de mensagem e a direção das mensagens. Para este processo, é usado o mecanismos de mensagens \textit{FIPA} (\textit{FIPA Agent Message Transport Service Specification}). \\

\lstset{language=XML,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\begin{lstlisting}
...
<!-- A direção da mensagem é "send", pois pretende-se apenas enviar mensagens -->
<messageevent name="inform_accident" type="fipa" direction="send">
 <parameter name="performative" class="String" direction="fixed">
 <!-- A mensagem é do tipo INFORM, pois contém apenas informações (e não uma query, por exemplo). O parâmetro "perfomative" tem de ser sempre especificado, pois define a intenção da mensagem. A direção é "fixed", pois representa informação estática -->
  <value>SFipa.INFORM</value>
 </parameter>
 <parameter name="language" class="String" direction="fixed">
 <!-- Aqui define-se a linguagem em que é feito o marshaling da mensagem. Esta tem de coincidir com a linguagem de recepção -->
  <value>SFipa.JADEX_XML</value>
 </parameter>
</messageevent>
\end{lstlisting}
\vspace{5 mm}

Depois de definir o evento é necessário criar o plano que enviará as mensagem. Como podem surgir sempre novos acidentes, o plano está sempre em execução. \\

\lstset{language=Java,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\begin{lstlisting}
...
//lista com todos os agentes do tipo condutor
IComponentIdentifier[] drivers = group.getAgentsForRole("Driver");
//lista de todos os acidentes do espaço
ISpaceObject[] accidents = space.getSpaceObjectsByType("accident");
//nova mensagem do tipo "inform_accident"
IMessageEvent me = createMessageEvent("inform_accident");
//definição dos recetores 
me.getParameter(SFipa.RECEIVERS).setValue(drivers);
//definição do conteúdo da mensagem, neste caso com os acidentes conhecidos
me.getParameter(SFipa.CONTENT).setValue(accidents);
sendMessage(me);
\end{lstlisting}
\vspace{5 mm}

Por sua vez, o processo do lado do condutor é semelhante. Depois de definir no \textit{XML} o evento de receção de mensagens (semelhante ao do rádio, mas com a direção definida como "\textit{receive}"), é necessário criar o plano que processa as mensagens recebidas. \\


\lstset{language=Java,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\begin{lstlisting}
...
//receção da mensagem
IMessageEvent req = (IMessageEvent) getReason();

//conteúdo da mensagem (sabemos à partida que é do tipo ISpaceObject[])
ISpaceObject[] accidents = (ISpaceObject[]) req.getParameter(SFipa.CONTENT).getValue();

//tratamento dos acidentes...
...
\end{lstlisting}
\vspace{5 mm}

\textbf{Mecanismo de escolha do próximo \textit{POI}\\}

O agente condutor age de dois modos: turístico ou direto. No turístico, tem como objetivo passar por todos os pontos de interesse, tendo em conta as suas pré-condições, estado do tempo e os acidentes antes de se dirigir para o seu destino. No direto, o objetivo é simplesmente chegar ao ponto final. Esse modo está representado no \textit{belief} "turistica" do condutor. \\

\lstset{language=XML,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\begin{lstlisting}
<belief name="turistica" class="boolean">
 <fact>true</fact>
</belief>
\end{lstlisting}
\vspace{5 mm}

Quando o agente é executado, há, assim, a intenção de se movimentar pelo espaço com vista a chegar ao ponto final. No \textit{Jadex}, essa intenção representa um \textit{goal} inicial, que será concretizado pelo respetivo \textit{plan} (isto é, pelo plano que é acionado pela intenção). O modo direto é simples, pois só é necessário calcular o caminho, caso exista, entre a posição do condutor e a posição definida como destino. \\

No caso em que o modo atual é o turístico, é necessário calcular o ponto mais próximo que satisfaz todas as pré-condições do meio (estado do tempo, pré-condições do próprio \textit{POI},...). Estas operações são processadas pelo \textit{plan} \textit{GoDestiny}.\\

\lstset{language=Java,breaklines=true, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize}
\begin{lstlisting}
//espaço em que o agente se insere, isto é, a que o GPS tem acesso
Space2D space = (Space2D) getBeliefbase().getBelief("environment").getFact();

//objeto condutor no espaço atual
ISpaceObject myself = (ISpaceObject) getBeliefbase().getBelief("myself").getFact();

//pontos de interesse do espaço
ISpaceObject[] poi = space.getSpaceObjectsByType("pointofinterest");

/*filtrados POIs que se podem visitar, de acordo com o estado do tempo e de acordo com as pré-condições de cada POI (se um POI está por visitar, mas tem como pré-condição visitar pontos ainda não visitados, este é retirado do Array)*/
poi = filter(poi, (String) space.getProperty("weather"));

...
//se existir um ponto ainda não visitado
 if(poi[i].getProperty("state")).equals("notvisited")) {
 
 ...
 //é calculado o caminho utilizando o A* e colocado no Array nodes
 ...
 
 //se o caminho for mais curto que o anterior
 if (nodes.size() < sizeant)
  target = poi[i];
 }
 
 //se existir um POI por visitar	 
 if (target != null) {
  //é criada a intenção de movimentar-se para o POI	
  go_target = createGoal("move.move_dest");
  
  //é definido o destino, para o respetivo plano depois ter acesso ao destino
  go_target.getParameter("destination").setValue(target.getProperty(Space2D.PROPERTY_POSITION));
  
  //o goal é executado e espera-se que termine
  dispatchSubgoalAndWait(go_target);
  
  //só depois de terminar, o estado o POI passa a visitado
  target.setProperty("state", "visited");
 }
 else {...} //no caso de não haver mais POIs, o condutor desloca-se para o final, utilizando o mesmo mecanismo descrito anteriormente
\end{lstlisting}
\vspace{5 mm}


\chapter{Experiências}


\section{Objetivo de cada experiência}

Foram realizadas experiências em três diferentes configurações, diferenciando no tipo de percurso e no número de agentes. Todas as configurações têm por base um mapa com dimensões de 30x30, ponto inicial e ponto final, bem como um rádio que pode ser ligado e desligado.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{mapa}
  \caption{Mapa do Mundo.}
\end{figure}

\section{Visita Turística}

Nesta configuração o condutor tem de ir do ponto inicial até ao ponto final passando por todos os pontos de interesse que se encontrem em condições de serem visitados.

\subsection{Todos os Pontos de Interesse de acordo com a sua posição}

Esta experiência tem como objectivo testar o algoritmo implementado, o A*. Analisando o mapa anterior conseguimos ver que a Igreja é o primeiro ponto a ser visitado pois é o que se encontra mais próximo da partida tal como demonstram os logs das ações.

Analisando os logs de um percurso completo e o mapa do mundo, vemos que o condutor percorre correctamente todos os pontos de interesse antes de chegar ao ponto final, tal como pretendido.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{todos_pois}
  \caption{Ações do condutor num percurso sem acidentes.}
\end{figure}

\subsection{Condições Atmosféricas}

Cada ponto de interesse tem uma condição atmosférica associada, ou seja, só pode ser visitado caso essa condição se verifique.

Tendo o estado do tempo definido com "Sol", e sendo que o Zoo só é visitado quando está sol o condutor terá que visita-lo. Nesta primeira experiência foi possível comprovar que tal acontece.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{zoo_sol}
  \caption{Ações do condutor com o estado do tempo "Sol".}
\end{figure}

Alterando agora o estado do tempo para "Chuva" verificamos positivamente que o condutor não visita o Zoo, tal como pretendido.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{zoo_chuva}
  \caption{Ações do condutor com o estado do tempo "Chuva".}
\end{figure}


Com estas duas experiências conseguimos ver que as decisões são tomadas de forma correta consoante o estado do tempo.

\subsection{Pré-Condições de Visita de um Ponto de Interesse}

Existem pontos de interesse que só podem ser visitados depois de outros pontos de interesse, como por exemplo, o Estádio que só pode ser visitado depois do Zoo e da Igreja.

Não existindo condições que impeçam a visita de nenhum dos pontos anteriores conseguimos ver que o condutor se comporta como pretendido e antes de visitar o estádio visita os outros dois pontos.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{estadio_com_pre}
  \caption{Ações do condutor quando visita o estádio com pré-condições.}
\end{figure}

Caso exista algum impedimento, como por exemplo, um acidente ou mais que bloqueiem por completo o acesso ao Zoo o Estádio não pode ser visitado. Nesta situação o condutor como pretendido vai para o ponto seguinte.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{estadio_falha_pre}
  \caption{Ações do condutor quando não visita o estádio pois falha uma pré-condição.}
\end{figure}

Neste caso podemos concluir que as pré-condições de um ponto influenciam corretamente a escolha do percurso.

\subsection{Rádio e Acidentes}

O rádio serve para alertar a existência dos acidentes no percurso, quando este se encontra desligado o condutor só fica a conhecer um acidente quando este se encontra no seu campo de visão, e só depois é que é calculado um caminho alternativo.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{radio_off}
  \caption{Ações do condutor quando o rádio se encontra desligado.}
\end{figure}

Caso o rádio esteja ligado, este informa o condutor de todos os acidentes existentes, podendo assim o -percurso ser calculado sabendo já que determinada rua se encontra impedida. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{radio_on}
  \caption{Ações do condutor quando o rádio se encontra ligado.}
\end{figure}

Podemos então assim verificar tanto que o condutor consegue detetar os acidentes existentes no caminho, bem como processar a informação recebida pelo rádio. Em ambos os casos é calculado corretamente um caminho alternativo caso este exista, senão o condutor fica parado a espera de uma alternativa.

\section{Direto}
 

Neste modo o condutor vai do ponto inicial para o ponto final sem passar por nenhum ponto de interesse.
Ao correr este modo verificamos positivamente que o condutor encaminha-se diretamente para o ponto final, sendo apenas influenciado pela existência ou não de acidentes. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{direto}
  \caption{Ações do condutor em percurso directo.}
\end{figure}

Tal como anteriormente verificamos que o condutor processa de forma correcta a informação relativa a um acidente, independentemente de estar ter vindo do rádio ou do seu raio de visão.

\section{Visita Turística com dois condutores}

No caso da visita turística com dois condutores, é introduzida uma nova forma de comunicação de acidentes. \\

Para testar esta comunicação foi feita uma simulação com o rádio desligado de modo a verificar que sempre que um condutor encontra um acidente informa o outro da existência do mesmo para que este possa escolher outro caminho, tendo funcionado tal como previsto. \\

\section{Resultados}

Ao analisar os resultados de todas as experiências podemos concluir que dados diversos cenários o condutor toma sempre as decisões de forma correta tendo sempre em vista o melhor caminho para o ponto de interesse seguinte ou para o ponto final. \\

\chapter{Conclusões}

O objetivo do trabalho passou por implementar um agente BDI capaz de aconselhar o condutor sobre o melhor percurso a realizar numa viagem de automóvel. Este foi totalmente satisfeito, e foram ainda implementadas funcionalidades adicionais que aumentam o valor da aplicação final, e a aproximam mais de casos reais.   \\

Tal como proposto, existem dois modos distintos: turístico e direto. O agente BDI não conhece inicialmente as condições da estrada e apenas sabe se há alguma acidente quando este se aproxima do seu raio de visão, ou o rádio está ligado. As condições atmosféricas são também tidas em conta na visita aos diferentes pontos de interesse. \\

Para além disso, cada ponto de interesse contém uma lista de pré-condições, constituída por pontos de interesse, e que restringem a visita a estes, tal como explicado ao longo do relatório. \\

Em relação à interface, o proposto seria visualizar as decisões do condutor e vê-lo a atuar no espaço. Para melhorar a interação com o utilizador, foi ainda acrescentada uma janela com informação relativa ao condutor, uma janela que permite interagir com o mapa de estradas e outra onde é possível consultar informação relativa ao estado atmosférico e aos pontos de interesse. \\

Durante as aulas práticas foi ainda sugerido incluir um cenário com mais do que um condutor e haver partilha de informação relativa a acidentes entre eles. Assim, o programa foi ligeiramente adaptado para ser possível demonstrar possíveis implementações e melhoramentos futuros, resultantes do aumento do âmbito do projeto inicial. \\ 

Para efeitos de demonstração, foram então preparados três cenários distintos - modo turístico, modo turístico com dois condutores e modo direto. Os testes efetuados permitiram verificar o correto funcionamento da aplicação em todos estes cenários, considerando igualmente a dinâmica da mudança das características do meio ambiente.  \\

A arquitetura BDI enquadra-se no cenário pretendido, pois o agente condutor pode ser facilmente modelado com base em conhecimentos, desejos e intenções. Esta arquitetura permite ainda distinguir o processo de execução de uma intenção do processo de deliberação de novas intenções, que podem surgir com a mudança do seu conhecimento, ou mesmo quando surgem novos desejos. Desta forma, o agente tem a capacidade de manter um equilíbrio entre ambas, possibilitando a sua execução em paralelo. No cenário proposto isto é fulcral, pois o condutor encontra-se normalmente em viagem, mas tem de estar constantemente em alerta para as mudanças do meio, que alteram o seu conhecimento e que podem alterar os seus desejos, e, por conseguinte, haver necessidade de mudar as intenções. \\


Consequently, BDI agents are able to balance the time spent on deliberating about plans (choosing what to do) and executing those plans (doing it). \\

Este projeto foi bastante enriquecedor, pois, para além de nos ter introduzido ao estudo de sistemas multi-agente, permitiu estudar, em particular, a arquitetura \textit{BDI} e a sua implementação em \textit{Jadex}. Apesar da dificuldade inicial em perceber e conseguir concretizar algumas ideias na ferramenta, os exemplos fornecidos e a documentação \textit{online} permitiram construir uma aplicação sólida e que ultrapassa os objetivos propostos. \\

\chapter{Melhoramentos}

Futuramente poderia ser criado um modo de inserção dinâmico de pontos de interesse no mapa. Teríamos ainda a possibilidade de alterar o ponto de destino durante a simulação, ou antes de esta começar também poderíamos alterar o ponto de partida e localização dos pontos de interesse.  

Finalmente poderíamos incluir a opção de adicionar e remover condutores da simulação, sendo assim possível criar um vasto leque de simulações diferentes.


\chapter{Recursos}
\section{Bibliografia}

\begin{itemize}
\item http://jadex-agents.informatik.uni-hamburg.de
\item http://paginas.fe.up.pt/~eol/AIAD/aiad1112.html
\item http://sourceforge.net/projects/jadex/
\end{itemize}


\section{Software}

\begin{itemize}
\item NetBeans - IDE utilizado para desenvolvimento.
\item Jadex 2.0
\item Git
\end{itemize}

\section{Elementos do grupo}

\begin{itemize}
\item Carlos Tiago Rocha Babo - 080509118
\item Bruno Filipe Neves Ferreira - 080509088
\item Hélder Alexandre dos Santos Moreira - 080509170
\end{itemize}

\chapter{Apêndice}
\section{Manual do utilizador}

Abrir o IDE e escolhe como main class "jadex.base.Starter".
Ao correr a aplicação abrirá a janela do Jadex Control Center, onde é necessário adicionar ao path a pasta "application" que se encontra dentro da pasta src do projecto.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{addPath}
  \caption{Janela do Path do Jadex Control Center.}
\end{figure}

Abrir a pasta "application", selecionar "BDIDriveAssistant.application.xml" e depois consoante o pretendido escolher uma das três opções na "Configuration" e carregar no botão Start.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{start}
  \caption{Janela Principal do Jadex Control Center.}
\end{figure}

Na interface principal é possível iniciar a simulação, ligar e desligar o Rádio, bem como adicionar e remover acidentes e caminhos no mapa.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{principal}
  \caption{Janela Principal.}
\end{figure}

Na janela das configurações do mundo é possível alterar o estado do tempo e ver os detalhes de cada ponto de interesse, nomeadamente as suas pré-condições e as condições atmosféricas em que é visitado.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{configs}
  \caption{Janela das Configurações do Mundo.}
\end{figure}

É possível ver os beliefs do condutor e as suas ações na janela do log das ações do condutor.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{logs}
  \caption{Janela das Ações do condutor.}
\end{figure}

A ultima janela, BDI Drive Assistant, mostra os diferentes pontos de interesse e acidentes do percurso, o ponto inicial e final, bem como o condutor a deslocar-se ao longo do mapa.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{driver}
  \caption{Janela do BDI Drive Assistant.}
\end{figure}


\end{document}